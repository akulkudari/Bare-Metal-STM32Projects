#include <stdint.h>
#include <stdio.h>

#define I2C_2_ADDRESS 0x40005800UL
#define RCC_BASE 0x40023800UL //RCC Base register address
#define RCC_APB1ENR (*(volatile uint32_t*)(RCC_BASE + 0x40)) //Address of APB1 Enable Register
#define RCC_APB1ENR_I2C2EN (1 << 22)                         //set the I2C2 port enable mask.
#define RCC_PLLCFGR (*(volatile uint32_t*)(RCC_BASE + 0x04))
#define RCC_CR ((*volatile uint32_t*)(RCC_BASE + 0x00))
#define RCC_CFGR (*(volatile uint32_t*)(RCC_BASE + 0x08))

typedef struct{
    volatile uint32_t CR1; //offset is 0x00
    /*
    * Control Register 1. 
    * Bit 0 - Peripheral Enable:
    *   -When 1, Peripheral Enabled
    * Bit 9 - STOP Generation: 
    *   As 1:
        *   -As a controller: Stop generation after the current byte transfer or after the current Start condition is sent
        *   -As a peripheral: Release the SCL and SDA lines after the current byte transfer. 
        As 0: 
        *   -No Stop condition is generated.
    * Bit 8 - START Generation: 
    *   As 1:
        *   -As a controller: Repeated Start Generation
        *   -As a peripheral: Start Generation when the bus is free
        As 0:
        *   -No Start condition is generated.
    * Bit 10 - Acknowledge Enable:
    *   As 1:
        *   -Acknowledge returned after a byte is received (matched address or data)
        As 0:
        *   -No Acknowledge returned after a byte is received
    */
    volatile uint32_t CR2; //offset is 0x04
    /*
    * Bit 10: Buffer interrupt enable: 
        - Controls whether an interrupt is generated when the data register is empty (TXE) or not full (RXNE)
    * Bit 9: Event interrupt enable: 
        - Controls whether an interrupt is generated by a few differnet events 
      Bit 8: Error interrupt enable: 
        - Controls whether an interrupt is generated by a few differnet error events
    * Bits 0-5: FREQ[5:0]: Peripheral clock frequency in MHz. 
        Can be set from 000010 to 110010 (2 to 50)
        Should be set to the value of the peripheral's clock
    */
    volatile uint32_t OAR1; //offset is 0x08 
    /*
    * Ignored in Master mode, useful if in peripheral mode. Compared with address sent on the bus by 
    * a controller to determine if the peripheral is being addressed. If matched, response is acknowledge.
    */
    volatile uint32_t OAR2; //offset is 0x0C
    /*
    * Ignored in Master mode, useful if in peripheral mode. Compared with address sent on the bus by 
    * a controller to determine if the peripheral is being addressed. If matched, response is acknowledge.
    */
    volatile uint32_t DR;   //offset is 0x10
    /* IMPORTANT REGISTER FOR DATA WRITES AND READS
    * Holds the data byte to be transmitted or received.
    * Bits 0-7 - Data Register
    *     - Transmitter Mode: Byte transmission starts automatically when 
    *       byte is writeen into the Data Register. Continuous transmission stream can
    *       be achieved if next data is put in DR once transmission is started (TxE = 1 / Data Register is Empty)
    *     - Receiver Mode: Byte is received and stored in DR. Reception is automatic
    *       and can be continuous if current byte in DR is read before new one is received. (RxNE = 1 / Data Register Not Empty).
    */
    volatile uint32_t SR1;  //offset is 0x14
    /*
    * Mostly read-only register that holds status flags
    */
    volatile uint32_t SR2;  //offset is 0x18
    /*
    * Mostly read-only register that holds status flags
    */
    volatile uint32_t CCR;  //offset is 0x1C
    /* CLock COntrol Register
    * Bit 15: Speed Mode controller (Fm vs Sm)
        - 0: Sm Mode I2C (Standard/Slow Mode, up to 100kHz clock)
        - 1: Fm mode I2c (Fast Mode, up to 400kHz clock)
    * Bit 14: Duty Cycle (only used in Fm mode)
        - 0: 2 (tlow / thigh = 2)
        - 1: 16/9 (tlow / thigh = 16/9)
    * Bits 0-11: CCR[11:0]: Clock Control Register in Sm or Fm mode
        - In Sm mode: CCR = TPCLK1 / (2 * FI2C)
        - In Fm mode: 
            - Duty = 0: CCR = TPCLK1 / (3 * FI2C)
            - Duty = 1: CCR = TPCLK1 / (25 * FI2C)
        HARDEST PART OF I2C CONFIGURATION TO GET RIGHT
    */
    volatile uint32_t TRISE; //offset is 0x20
    /*
    * Bit 0-5: TRISE[5:0]: Maximum Rise Time in Fm mode or Sm mode
        - In Sm mode: TRISE = (Maximum Rise Time / TPCLK1) + 1
            - Max Rise Time = 1000ns
        - In Fm mode: TRISE = (Maximum Rise Time / TPCLK1) + 1
            - Max Rise Time = 300ns
    */
    volatile uint32_t FLTR;  //offset is 0x24
    /*
    * Bit 4: Analog Filter OFF
        - 0: Analog filter Enabled
        - 1: Analog filter Disabled
    * Bits 0-3: DNF[3:0]: Digital Noise Filter Coefficient
        - Configures the duration of spikes that must be filtered out by the digital filter
    */
   }
    I2C_TypeDef;

#define I2C2 ((I2C_TypeDef *) I2C_2_ADDRESS)

void start_I2C(void){
    I2C2->CR1 |= (1 << 8); //Set START bit in CR1 to generate Start Condition
    while(!(I2C2->SR1 & (1 << 0))); //Wait until SB (Start Bit) is set in SR1
}   

void stop_I2C(void){
    I2C2->CR1 |= (1 << 9); //Set STOP bit in CR1 to generate Stop Condition
    //No need to wait for anything, Stop condition is generated automatically
}
int8_t Ds3231_Read(char address, char *data, uint8_t reads)
{
        I2C2->CR1 &= ~(0x500);
        I2C2->CR1 |= (1 << 8);
        I2C2->CR1 |= (1 << 10);
        while (!(I2C2->SR1 & (1 << 0)));

        I2C2->DR = 0xd0;

        while (!(I2C2->SR1 & (1 << 1)));


        while (!(I2C2->SR1 & (1 << 7)));    
        I2C2->DR = address;

        while (!(I2C2->SR1 & (1 << 2)));

        I2C2->CR1 |= (1 << 8);

        while (!(I2C2->SR1 & (1 << 0)));
        I2C2->DR = 0xd1;

        while (!(I2C2->SR1 & (1 << 1)));

        for (uint8_t i = 0; i < reads; i++, data++)
        {
            if (i + 1 == reads)
            {
                I2C2->CR1 &= ~(1 << 10);

                I2C2->CR1 |= (1 << 9);
            }

            while (!(I2C2->SR1 & (1 << 6))); //Wait until RXNE is set

            *data = I2C2->DR;
        }

        return 0;
}

int8_t Ds3231_Write(char address, char data)
{

    I2C2->CR1 |= (1 << 8) |
                (1 << 10);

    while (!(I2C2->SR1 & (1 << 0)));

    I2C2->DR = 0xD0;

    while (!(I2C2->SR1 & (1 << 1)));


    while (!(I2C2->SR1 & (1 << 7))); //Wait until TXE is set

    I2C2->DR = address;

    while (!(I2C2->SR1 & (1 << 2))); //Wait until Byte Transfer Finished (_BTF)) is set

    while (!(I2C2->SR1 & (1 << 7))); //Wait until TXE is set

    I2C2->DR = data;

    while (!(I2C2->SR1 & (1 << 2))); //Wait until Byte Transfer Finished (BTF) is set

    I2C2->CR1 |= (1 << 9);

    return 0;
}
// calling the function
